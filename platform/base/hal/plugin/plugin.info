#
# This plugin.info file is for HAL-related plugins.
#

# New plugins should be based on the following template.  Unused sections from
# the template should be removed.  Other options are available.  Ask tools_dev
# for help.  Sort plugins alphabetically by id.
#plugin(my-plugin) {
#  name=My Plugin
#  description=An example plugin.
#  category=HAL
#  quality=sample
#  root=$HAL/my-plugin
#
#  architecture=efr32,em357,simulation
#
#  providedApis=my-provided-api1,my-provided-api2
#  api.my-provided-api1.header=my-provided-api1.h
#  api.my-provided-api2.header=my-provided-api2.h
#
#  requiredApis=my-required-api1,my-required-api2
#
#  my-file-common.c
#  my-file-efr32.c      (efr32)
#  my-file-em357.c      (em357)
#  my-file-simulation.c (simulation)
#
#  callbacks=my-callback.info
#
#  options=myBooleanOption,myNumberOption
#
#  myBooleanOption.name=My boolean option
#  myBooleanOption.description=An option that sets a boolean.
#  myBooleanOption.type=BOOLEAN
#  myBooleanOption.default=FALSE
#
#  myNumberOption.name=My number option
#  myNumberOption.description=An option that sets a number.
#  myNumberOption.type=NUMBER
#  myNumberOption.default=0
#
#  setup(bookkeeping) {
#    init=myInitHandler
#    tick=myTickHandler
#  }
#
#  setup(eventConfiguration) {
#    myEvent1Control, myEvent1Handler
#    myEvent2Control, myEvent2Handler
#  }
#
#  setup(macros) {
#    MY_CONFIGURATION_HEADER_MACRO
#    -DMY_PROJECT_MACRO
#  }
#}

pluginDirectory=.

plugin(accelerometer-led) {
  name=Accelerometer LED
  description=Implements Bosch BMA222E interface via I2C for GPIO wake-up on motion and sets a status LED to reflect accelerometer activity.
  category=HAL
  quality=sample
  root=$HAL

  # TODO: Port this plugin to the EFR32 (EMHAL-1094).
  architecture=em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598

  providedApis=accelerometer-led
  api.accelerometer-led.header=plugin/accelerometer-led/accelerometer-led.h

  requiredApis=event,i2c-driver

  plugin/accelerometer-led/accelerometer-led.c

  setup(bookkeeping) {
    init=halAccelerometerLedInitialize
  }

  setup(eventConfiguration) {
    halAccelerometerLedTimeoutEventControl, halAccelerometerLedTimeoutEventHandler
  }
}

plugin(button) {
  name=Button
  description=Sample API functions for operating buttons (external interrupts).
  category=HAL
  quality=sample
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation,stm32f103ret

  providedApis=button
  api.button.header=micro/button.h

  requiredApis=hal

  setup(hwConfig) {
  dependentHwConfModules=BUTTON
  }

  host/cortexm3/stm32f103ret/button.c (stm32f103ret)
  micro/cortexm3/button.c             (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/efm32/button.c       (efr32)
  micro/unix/simulation/button.c      (simulation)

  callbacks=config/button-callback.info
}

plugin(button-stub) {
  name=Button Stub
  description=Stub implementation of the button API for devices that do not use buttons.
  category=HAL
  quality=stub
  root=$HAL

  providedApis=button
  api.button.header=micro/button.h

  micro/generic/button-stub.c
}

plugin(buzzer) {
  name=Buzzer
  description=Sample API functions for using a timer to play tunes on a buzzer.
  category=HAL
  quality=sample
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation,stm32f103ret

  providedApis=buzzer
  api.buzzer.header=plugin/buzzer/buzzer.h

  requiredApis=hal

  plugin/buzzer-stub/buzzer-stub.c    (simulation)
  plugin/buzzer/buzzer-efr32.c        (efr32)
  plugin/buzzer/buzzer-em3xx.c        (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  plugin/buzzer/buzzer-stm32f103ret.c (stm32f103ret)
}

plugin(buzzer-stub) {
  name=Buzzer Stub
  description=Stub implementation of the buzzer API for devices that do not use buzzers.
  category=HAL
  quality=stub
  root=$HAL

  providedApis=buzzer
  api.buzzer.header=plugin/buzzer/buzzer.h

  plugin/buzzer-stub/buzzer-stub.c
}

plugin(diagnostic) {
  name=Diagnostic
  description=Program counter diagnostic functions.
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=diagnostic-cortexm3,diagnostic
  api.diagnostic-cortexm3.header=micro/cortexm3/diagnostic.h
  api.diagnostic-cortexm3.condition=conf.architectureMatches("efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598")
  api.diagnostic.header=micro/diagnostic.h

  requiredApis=hal,printf,serial

  micro/cortexm3/diagnostic.c       (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/efm32/diagnostic.c (efr32)
  micro/generic/diagnostic-stub.c   (simulation)
}

plugin(diagnostic-stub) {
  name=Diagnostic Stub
  description=Stub implementation of the diagnostic API for devices that do not use diagnostics.
  category=HAL
  quality=stub
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=diagnostic
  api.diagnostic.header=micro/diagnostic.h

  micro/generic/diagnostic-stub.c
}

plugin(debug-channel) {
  name=Debug JTAG
  description=Debug Transport Mechanism (JTAG) to be used with the debug channel.
  category=HAL
  quality=development
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation
  
  providedApis=debug-channel
  api.debug-jtag.header=plugin/debug-jtag/debug-channel.h
  
  requiredApis=hal
  
  plugin/debug-jtag/debug-jtag-em3xx.c  (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  plugin/debug-jtag/debug-jtag-efr32.c  (efr32)
  plugin/debug-jtag/debug-jtag-sim.c    (simulation)

  setup(hwConfig) {
    dependentHwConfModules=GPIO
  }
}

plugin(debug-channel-stub) {
  name=Debug JTAG stub
  description=Stub implementation of Debug Transport Mechanism (JTAG) to be used with the debug channel.
  category=HAL
  quality=stub
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation
  
  providedApis=debug-channel
  api.debug-jtag.header=plugin/debug-jtag/debug-channel.h
  
  requiredApis=hal
  
  $HAL/plugin/debug-jtag-stub/debug-jtag-stub.c (efr32,em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation)
}

plugin(ext-device) {
  name=External Device GPIO Driver
  description=This plugin provides functionality to drive an external device's GPIO.
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=ext-device
  api.diagnostic.header=micro/cortexm3/ext-device.h

  setup(hwConfig) {
  dependentHwConfModules=EXTDEV
  }

  micro/cortexm3/ext-device.c       (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
}

plugin(hal-library) {
  name=HAL Library
  description=Common functionality for systems-on-chip (SoCs).
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=aes,crc,endian,hal,random,system-timer,token-cortexm3,token
  api.crc.header=micro/crc.h
  api.endian.header=micro/endian.h
  api.hal.header=hal.h
  api.random.header=micro/random.h
  api.system-timer.header=micro/system-timer.h
  api.token-cortexm3.header=micro/cortexm3/token.h
  api.token-cortexm3.condition=conf.architectureMatches("efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598")
  api.token.header=micro/token.h

  requiredApis=adc,serial,token-storage,coexistence

  # TODO: What else is required for EFR32?
  $FRAMEWORK/../../tool/simulator/child/child-main.c (simulation)
  $FRAMEWORK/../../tool/simulator/child/timer.c      (simulation)
  $FRAMEWORK/../../tool/simulator/child/uart.c       (simulation)
  micro/cortexm3/assert-crash-handlers.c             (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/caladc.c                            (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/clocks.c                            (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/context-switch.s79                  (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/cstartup-common.c                   (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/efm32/assert-crash-handlers.c       (efr32)
  micro/cortexm3/efm32/cstartup-common.c             (efr32)
  micro/cortexm3/efm32/cstartup-$--toolchainName--$.c                (efr32)
  micro/cortexm3/efm32/faults-v7m.s79                (efr32)
  micro/cortexm3/efm32/flash.c                       (efr32)
  micro/cortexm3/efm32/hal-config.c                  (efr32)
  micro/cortexm3/efm32/hal-config-gpio.c             (efr32)
  micro/cortexm3/efm32/isr-stubs.s79                 (efr32)
  micro/cortexm3/efm32/long-token.c                  (efr32)
  micro/cortexm3/efm32/mfg-token.c                   (efr32)
  micro/cortexm3/efm32/micro-common-internal.c       (efr32)
  micro/cortexm3/efm32/micro-common.c                (efr32)
  micro/cortexm3/efm32/micro-internal.c              (efr32)
  micro/cortexm3/efm32/micro.c                       (efr32)
  micro/cortexm3/efm32/register-access.c             (efr32)
  micro/cortexm3/efm32/sleep-efm32.c                 (efr32)
  micro/cortexm3/efm32/system-timer.c                (efr32)
  micro/cortexm3/efm32/token.c                       (efr32)
  $SERVICE/mpu/src/sl_mpu.c                          (efr32)
  micro/cortexm3/em35x/cstartup-iar.c                (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/faults.s79                          (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/flash.c                             (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/isr-stubs.s79                       (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/mfg-token.c                         (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/micro-common-internal.c             (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/micro-common.c                      (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/micro-internal.c                    (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/micro.c                             (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/mpu.c                               (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/sleep.c                             (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/spmr.s79                            (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/system-timer.c                      (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/token.c                             (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/uart.c                              (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/usb/cdc/callbacks.c                 (em3582,em3586,em3588,em3592,em3596,em3598)
  micro/cortexm3/usb/cdc/descriptors.c               (em3582,em3586,em3588,em3592,em3596,em3598)
  micro/cortexm3/usb/em_usbd.c                       (em3582,em3586,em3588,em3592,em3596,em3598)
  micro/cortexm3/usb/em_usbdch9.c                    (em3582,em3586,em3588,em3592,em3596,em3598)
  micro/cortexm3/usb/em_usbdep.c                     (em3582,em3586,em3588,em3592,em3596,em3598)
  micro/cortexm3/usb/em_usbhal.c                     (em3582,em3586,em3588,em3592,em3596,em3598)
  micro/cortexm3/usb/em_usbint.c                     (em3582,em3586,em3588,em3592,em3596,em3598)
  micro/cortexm3/usb/em_usbtimer.c                   (em3582,em3586,em3588,em3592,em3596,em3598)
  micro/generic/aes/rijndael-alg-fst.c               (simulation)
  micro/generic/aes/rijndael-api-fst.c               (simulation)
  micro/generic/crc.c                                (efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/generic/endian.c                             (efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation)
  micro/generic/mem-util.c                           (efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/generic/random.c                             (efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/generic/token-def.c                          (efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/generic/token-ram.c                          (simulation)
  micro/unix/simulation/bootloader.c                 (simulation) # TODO: Should this be added by the bootloader setup?
  micro/unix/simulation/crc-sim.c                    (simulation) # TODO: Can we use micro/generic/crc.c instead?
  micro/unix/simulation/fake-eeprom.c                (simulation)
  micro/unix/simulation/micro.c                      (simulation)
  micro/unix/simulation/random-sim.c                 (simulation)
  micro/unix/simulation/symbol-timer-sim.c           (simulation)
  micro/unix/simulation/system-timer-sim.c           (simulation)
  $DEVICE/SiliconLabs/em34x/Source/IAR/irqToIsrTrampolines_em34x.s   (em341+iar,em342+iar,em346+iar)
  $DEVICE/SiliconLabs/em35x/Source/IAR/irqToIsrTrampolines_em35x.s   (em351+iar,em355+iar,em356+iar,em357+iar)
  $DEVICE/SiliconLabs/em355x/Source/IAR/irqToIsrTrampolines_em355x.s (em3555+iar)
  $DEVICE/SiliconLabs/em358x/Source/IAR/irqToIsrTrampolines_em358x.s (em3581+iar,em3582+iar,em3585+iar,em3586+iar,em3587+iar,em3588+iar)
  $DEVICE/SiliconLabs/em359x/Source/IAR/irqToIsrTrampolines_em359x.s (em3591+iar,em3592+iar,em3595+iar,em3596+iar,em3597+iar,em3598+iar)
  $DEVICE/SiliconLabs/em34x/Source/GCC/irqToIsrTrampolines_em34x.s   (em341+gcc,em342+gcc,em346+gcc)
  $DEVICE/SiliconLabs/em35x/Source/GCC/irqToIsrTrampolines_em35x.s   (em351+gcc,em355+gcc,em356+gcc,em357+gcc)
  $DEVICE/SiliconLabs/em355x/Source/GCC/irqToIsrTrampolines_em355x.s (em3555+gcc)
  $DEVICE/SiliconLabs/em358x/Source/GCC/irqToIsrTrampolines_em358x.s (em3581+gcc,em3582+gcc,em3585+gcc,em3586+gcc,em3587+gcc,em3588+gcc)
  $DEVICE/SiliconLabs/em359x/Source/GCC/irqToIsrTrampolines_em359x.s (em3591+gcc,em3592+gcc,em3595+gcc,em3596+gcc,em3597+gcc,em3598+gcc)

  callbacks=config/hal-callback.info

  precompiled(efr32) {
    file=$FRAMEWORK/../../build/hal-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$$--stackProtection--$/hal-library.a
    micro/cortexm3/efm32/clocks.c
    micro/cortexm3/efm32/cstartup-$--toolchainName--$.c
    micro/cortexm3/efm32/flash.c
    micro/cortexm3/efm32/micro-common-internal.c
    micro/cortexm3/efm32/micro-internal.c
    micro/cortexm3/efm32/register-access.c
    micro/cortexm3/efm32/system-timer.c
  }

  precompiled(em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598) {
    file=$FRAMEWORK/../../build/hal-library-cortexm3-iar-$--partNumber;L--$-em3xx$--stackProtection--$/hal-library.a
    micro/cortexm3/caladc.c
    micro/cortexm3/clocks.c
    micro/cortexm3/context-switch.s79
    micro/cortexm3/em35x/cstartup-iar.c
    micro/cortexm3/flash.c
    micro/cortexm3/micro-common-internal.c
    micro/cortexm3/micro-internal.c
    micro/cortexm3/spmr.s79
    micro/cortexm3/system-timer.c
  }

  precompiled(simulation) {
    file=$FRAMEWORK/../../build/hal-library-unix-gcc-simulation$--dynamicPhy--$/hal-library.a
    micro/generic/aes/rijndael-alg-fst.c
    micro/generic/aes/rijndael-api-fst.c
  }

  setup(additionalFiles) {
    (efr32)=PATH(ABSOLUTE):$SERVICE/mpu/inc
  }

  setup(macros){
    -DEMLIB_USER_CONFIG
  }

  setup(template){
    (efr32~series[1]):lockbitsInMainflashSize=0
    (efr32~series[2]):lockbitsInMainflashSize=8192
    (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598):lockbitsInMainflashSize=0
    headerSize=512
    (em317,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598):headerSize=256
    (efr32~series[1]~device_configuration[1]):headerSize=256
    (efr32~series[1]~device_configuration[3]):headerSize=256
    (efr32~series[1]~device_configuration[4]):headerSize=256
    (efr32):btlSize=16384
    (efr32~series[2]~device_configuration[2]):btlSize=24576

    # The GNU linker needs to be told how large certain sections are. This plugin
    # defaults them to zero and the corresponding plugins, when enabled, override
    # each one individually with a more specific template setup line.
    psstoreSize=0
    longTokenSize=0
  }
}

plugin(i2c-driver) {
  name=I2C Driver
  description=Implements an I2C driver that can be called by other plugins at main() level.
  category=HAL
  quality=sample
  root=$HAL

  # TODO: Port this plugin to the EFR32 (EMHAL-1095).
  architecture=em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=i2c-driver
  api.i2c-driver.header=plugin/i2c-driver/i2c-driver.h

  plugin/i2c-driver-stub/i2c-driver-stub.c (simulation)
  plugin/i2c-driver/i2c-driver-em3xx.c     (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)

  setup(bookkeeping) {
    init=halI2cInitialize
  }

  options=transactionTimeout

  transactionTimeout.name=Transaction timeout (ms)
  transactionTimeout.description=The amount of time (in ms) the I2C host will wait before marking a (possibly clock stretched) transaction as failed.
  transactionTimeout.type=NUMBER:1,1000
  transactionTimeout.default=50
}

plugin(key-matrix) {
  name=Key Matrix
  description=Sample API functions for operating key-matrix scanning (GPIO polling).
  category=HAL
  quality=sample
  root=$HAL

  # TODO: Port this plugin to the EFR32 (EMHAL-1096).
  architecture=em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598

  providedApis=key-matrix
  api.key-matrix.header=plugin/key-matrix/key-matrix-driver.h

  requiredApis=hal

  plugin/key-matrix/key-matrix-driver.c

  setup(bookkeeping) {
    init=halKeyMatrixInitialize
  }
}

plugin(led) {
  name=LED
  description=LED manipulation routines and example APIs.
  category=HAL
  quality=sample
  root=$HAL

  architecture=efr32,em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation,stm32f103ret

  providedApis=led
  api.led.header=micro/led.h

  requiredApis=hal

  setup(hwConfig) {
  dependentHwConfModules=LED
  }

  host/cortexm3/stm32f103ret/led.c (stm32f103ret)
  micro/cortexm3/led.c             (em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  micro/cortexm3/efm32/led.c       (efr32)
  micro/generic/led-stub.c         (simulation)
}

plugin(led-stub) {
  name=LED Stub
  description=Stub implementation of the LED API for devices that do not use LEDs.
  category=HAL
  quality=stub
  root=$HAL

  providedApis=led
  api.led.header=micro/led.h

  micro/generic/led-stub.c
}

plugin(microphone-codec-msadpcm) {
  name=Microphone Codec MSADPCM
  description=Implements digital microphone interface via an external codec, timer, I2C, and SPI (as I2S input) for 16kSps of 16-bit data using MS ADPCM 4:1 compression.
  category=HAL
  quality=sample
  root=$HAL

  # TODO: Port this plugin to the EFR32 (EMHAL-1097).
  architecture=em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598

  providedApis=microphone-codec-msadpcm
  api.microphone-codec-msadpcm.header=plugin/microphone-codec-msadpcm/microphone-codec-msadpcm.h

  requiredApis=event,i2c-driver

  plugin/microphone-codec-msadpcm/microphone-codec-msadpcm.c
  plugin/microphone-codec-msadpcm/msadpcm.c

  callbacks=config/microphone-codec-msadpcm-callback.info

  setup(bookkeeping) {
    init=halMicrophoneCodecMsadpcmInitialize
  }

  setup(eventConfiguration) {
    halMicrophoneCodecMsadpcmDataReadyEventControl, halMicrophoneCodecMsadpcmDataReadyEventHandler
  }
}

plugin(microphone-imaadpcm) {
  name=Microphone IMAADPCM
  description=Implements digital microphone interface via a SPI interface to convert 1.2MSps of 1-bit PDM data to 16kSps of 16-bit data using IMA ADPCM 4:1 compression.
  category=HAL
  quality=sample
  root=$HAL

  # TODO: Port this plugin to the EFR32 (EMHAL-1134).
  architecture=em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598

  providedApis=microphone-imaadpcm
  api.microphone-imaadpcm.header=plugin/microphone-imaadpcm/microphone-imaadpcm.h

  requiredApis=event

  plugin/microphone-imaadpcm/imaadpcm.c
  plugin/microphone-imaadpcm/microphone-imaadpcm-equalizer.c
  plugin/microphone-imaadpcm/microphone-imaadpcm.c

  callbacks=config/microphone-imaadpcm-callback.info

  precompiled(em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598) {
    file=$FRAMEWORK/../../build/microphone-imaadpcm-library-cortexm3-iar-$--partNumber;L--$-em3xx/microphone-imaadpcm-library.a
    plugin/microphone-imaadpcm/imaadpcm.c
    plugin/microphone-imaadpcm/microphone-imaadpcm.c
  }

  setup(eventConfiguration) {
    halMicrophoneImaadpcmDataReadyEventControl, halMicrophoneImaadpcmDataReadyEventHandler
  }
}

plugin(nvm3) {
  name=NVM3 Library
  description=The NVM3 provides a means to store and retrieve objects (key/value pair) from the flash and provides wear leveling to reduce erase and write cycles to maximise the lifetime of the flash pages. Objects in NVM3 can either be accessed directly through the native NVM3 API or through the token API in the same way as SimEE1 or SimEE2 based tokens. This library requires the Simulated EEPROM version 2 to NVM3 upgrade library or stub upgrade library. The number of flash pages to use for the NVM3 storage is configurable through the plugin options. IMPORTANT When compiling for a device which already contains NVM3 data, the number of flash pages configured for the compilation must match the number of flash pages used for the existing NVM3 instance on the device.
  category=HAL
  root=$HAL

  qualityString=Production Ready
  quality=Production

  architecture=efr32, simulation

  defaultState(efr32~series[2])=enabled

  providedApis=nvm3, token-storage, ble-token-storage

  requiredApis=sim-eeprom2-to-nvm3-upgrade

  api.nvm3.header= $HAL/plugin/nvm3/nvm3-token.h

  precompiled(efr32~series[1]+iar) {
    file=$EMDRV/nvm3/lib/libnvm3_CM4_iar.a
  }
  precompiled(efr32~series[1]+gcc) {
    file=$EMDRV/nvm3/lib/libnvm3_CM4_gcc.a
  }
  precompiled(efr32~series[2]+iar) {
    file=$EMDRV/nvm3/lib/libnvm3_CM33_iar.a
  }
  precompiled(efr32~series[2]+gcc) {
    file=$EMDRV/nvm3/lib/libnvm3_CM33_gcc.a
  }

  $EMDRV/nvm3/src/nvm3_default.c    (efr32)
  $EMDRV/nvm3/src/nvm3_hal_flash.c  (efr32)
  $EMDRV/nvm3/src/nvm3_lock.c

  $EMDRV/nvm3/src/nvm3.c            (simulation)
  $EMDRV/nvm3/src/nvm3_hal_ram.c    (simulation)
  $EMDRV/nvm3/src/nvm3_page.c       (simulation)
  $EMDRV/nvm3/src/nvm3_object.c     (simulation)
  $EMDRV/nvm3/src/nvm3_cache.c      (simulation)
  $EMDRV/nvm3/src/nvm3_utils.c      (simulation)

  setup(additionalFiles) {
    PATH(ABSOLUTE):$EMDRV/nvm3/inc
    (simulation)=PATH(ABSOLUTE):$EMDRV/nvm3/config
    (simulation)=PATH(ABSOLUTE):$EMDRV/common/inc
  }

  callbacks=config/nvm3-callback.info

  options=flashPages, cacheSize, maxObjectSize, userRepackHeadroom, simulation

  flashPages.name=Flash Pages
  flashPages.description= Number of flash pages to use for data storage in NVM3. When compiling for a device which already contains NVM3 data, the number of flash pages configured for the compilation must match the number of flash pages used for the existing NVM3 instance on the device.
  flashPages.type=NUMBER:3,1000
  flashPages.macro=-DNVM3_FLASH_PAGES
  flashPages.default(efr32~series[1])=18
  flashPages.default(efr32~series[2])=4
  flashPages.default=4

  cacheSize.name=Cache Size
  cacheSize.description= Number of NVM3 objects to cache. To reduce access times this number should be equal to or higher than the number of NVM3 objects in the default NVM3 instance, including tokens.
  cacheSize.type=NUMBER
  cacheSize.macro=-DNVM3_DEFAULT_CACHE_SIZE
  cacheSize.default=200

  maxObjectSize.name=Max Object Size
  maxObjectSize.description= Max NVM3 object size that can be stored. Note that only objects with size up to 254 bytes can be defined and accessed through the token API. For larger objects the native NVM3 API must be used.
  maxObjectSize.type=NUMBER:208,4096
  maxObjectSize.macro=-DNVM3_DEFAULT_MAX_OBJECT_SIZE
  maxObjectSize.default=254

  userRepackHeadroom.name=User Repack Headroom
  userRepackHeadroom.description= Headroom determining how many bytes below the forced repack limit the user repack limit should be placed. The default is 0, which means the user and forced repack limits are equal.
  userRepackHeadroom.type=NUMBER
  userRepackHeadroom.macro=-DNVM3_DEFAULT_REPACK_HEADROOM
  userRepackHeadroom.default=0

  simulation.hidden=true
  simulation.type=BOOLEAN
  simulation.description= Hidden boolean used to conditionally define simulation macros.
  simulation.default(simulation)=true
  simulation.default=false

  setup(macros) {
      -DUSE_NVM3
      -DNVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE
      simulation=true:-DNVM3_HOST_BUILD
      simulation=true:-DFLASH_PAGE_SIZE=2048
    }

  setup(template) {
    simeepromSize=$--(nvm3_flashPages*pageSize)--$
  }

}

plugin(sim-eeprom1) {
  name=Simulated EEPROM version 1 Library
  description=This library simulates an EEPROM within the internal flash of the chip to maximize the lifetime of flash pages and reduce write cycles.  The simulated EEPROM extends the lifetime of flash by wear leveling writes across the flash.  It is used for persistent storage of tokens for the network and application layers.  The network tokens are automatically managed by the network stack.  The application may add its own tokens.  SimEE1 and SimEE2 share the same fundamental limits on maximum number of tokens, maximum token or element size, and maximum number of elements in an indexed token. Maximum sum total of all token sizes is 2 kB in version 1 and 8 kB in version 2.  Version 1 uses less flash than Version 2, but version 1 is not optimized for writes during time critical operations.  Page erasure is under application control due to requiring the chip to disable interrupts during the erasure.  See Application note AN703 for more information.
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32~series[1],em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=sim-eeprom,token-storage
  api.sim-eeprom.header=plugin/sim-eeprom/sim-eeprom.h

  requiredApis=hal

  plugin/sim-eeprom1/sim-eeprom-internal.c (efr32~series[1],em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  plugin/sim-eeprom1/sim-eeprom.c          (efr32~series[1],em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)

  options=destructiveSimee2To1Downgrade

  destructiveSimee2To1Downgrade.name=Destructive SimEE version 2 to version 1 downgrade
  destructiveSimee2To1Downgrade.description=Enabling this option will cause SimEE version 1 to not check for the existence of SimEE version 2 data in flash.  The consequence of enabling the destructive downgrade is any and all SimEE data from using version 2 will be ignored, eventually deleted, and all SimEE tokens will be instantiated with their default, compile time values.  Not enabling this option will cause SimEE version 1 to assert if SimEE version 2 is found in the flash.  Asserting if SimEE2 is found prevents any accidental token deletion by running version 1 on a device.  Destructive downgrade is the only downgrade option.
  destructiveSimee2To1Downgrade.type=BOOLEAN
  destructiveSimee2To1Downgrade.default=FALSE
  destructiveSimee2To1Downgrade.define=DESTRUCTIVE_SIMEE2TO1_DOWNGRADE

  precompiled(efr32~series[1]) {
    file=$FRAMEWORK/../../build/sim-eeprom1-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$$--stackProtection--$/sim-eeprom1-library.a
    plugin/sim-eeprom1/sim-eeprom-internal.c
  }

  precompiled(em346,em351,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598) {
    file=$FRAMEWORK/../../build/sim-eeprom1-library-cortexm3-iar-$--partNumber;L--$-em3xx$--stackProtection--$/sim-eeprom1-library.a
    plugin/sim-eeprom1/sim-eeprom-internal.c
  }

  setup(template) {
    simeepromSize=8192
  }
}

plugin(sim-eeprom2) {
  name=Simulated EEPROM version 2 Library
  description=This library simulates an EEPROM within the internal flash of the chip to maximize the lifetime of flash pages and reduce write cycles.  The simulated EEPROM extends the lifetime of flash by wear leveling writes across the flash.  It is used for persistent storage of tokens for the network and application layers.  The network tokens are automatically managed by the network stack.  The application may add its own tokens.  SimEE1 and SimEE2 share the same fundamental limits on maximum number of tokens, maximum token or element size, and maximum number of elements in an indexed token. Maximum sum total of all token sizes is 2 kB in version 1 and 8 kB in version 2.  Version 2 is designed to reduce the time needed when an application writes a token, at the expense of consuming more flash.  Therefore SimEE2 is more appropriate when writing an element within a large set of tokens during time critical operations.  For example setting a binding within a 100 entry binding table.  Page erasure is under application control, via a callback, due to requiring the chip to disable interrupts during the erasure.  See Application note AN703 for more information.  This library requires the Simulated EEPROM version 1 to version 2 upgrade stub library or upgrade library.  The upgrade stub library is recommended since the stub adds minimal code space.  The full upgrade library should only be used when there are existing units in the field using SimEE1 that are meant to be upgraded.
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32~series[1],em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=sim-eeprom,token-storage
  api.sim-eeprom.header=plugin/sim-eeprom/sim-eeprom.h
  requiredApis=hal,sim-eeprom2-1to2-upgrade

  plugin/sim-eeprom2/sim-eeprom2-internal.c (efr32~series[1],em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)
  plugin/sim-eeprom2/sim-eeprom2.c          (efr32~series[1],em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)

  options=password
  conditions=verify

  password.name=Password
  password.description=The Simulated EEPROM 2 Library requires a password with which the user can access the data.
  password.type=STRING
  password.default=

  verify.expression=password.equals("!spoon")
  verify.message=Invalid password specified in the plugin options.  Please see Application Note AN703 to obtain the password and for more information on choosing SimEE2.

  precompiled(efr32~series[1]) {
    file=$FRAMEWORK/../../build/sim-eeprom2-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$$--stackProtection--$/sim-eeprom2-library.a
    plugin/sim-eeprom2/sim-eeprom2-internal.c
  }

  precompiled(em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598) {
    file=$FRAMEWORK/../../build/sim-eeprom2-library-cortexm3-iar-$--partNumber;L--$-em3xx$--stackProtection--$/sim-eeprom2-library.a
    plugin/sim-eeprom2/sim-eeprom2-internal.c
  }

  setup(macros) {
    -DUSE_SIMEE2
  }

  setup(template) {
    simeepromSize=36864
  }
}

plugin(sim-eeprom2-1to2-upgrade) {
  name=Simulated EEPROM version 1 to version 2 Upgrade Library
  description=Systems using SimEE2 must have this upgrade library or the upgrade stub library.  The upgrade stub library is recommended since the stub adds minimal code space.  The full upgrade library should only be used when there are existing units in the field using SimEE1 that are meant to be upgraded.  This library upgrades a device that used Simulated EEPROM version 1 to Simulated EEPROM version 2.  This upgrade code is a companion to the main Simulated EEPROM 2 library and the upgrade cannot be run on its own.  This upgrade library runs a simplified copy of the Simulated EEPROM version 1 startup process to find all existing tokens in flash.  This upgrade library only ever reads flash.  An official token repair process handled by the full Simulated EEPROM version 2 will then perform a standard repair.  A standard repair process copies over the found tokens and fills missing tokens with their default, compile time values.
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32~series[1],em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=sim-eeprom2-1to2-upgrade

  plugin/sim-eeprom2-1to2upgrade/sim-eeprom2-internal-1to2upgrade.c (efr32~series[1],em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)

  precompiled(efr32~series[1]) {
    file=$FRAMEWORK/../../build/sim-eeprom2-1to2-upgrade-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$$--stackProtection--$/sim-eeprom2-1to2-upgrade-library.a
    plugin/sim-eeprom2-1to2upgrade/sim-eeprom2-internal-1to2upgrade.c
  }

  precompiled(em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598) {
    file=$FRAMEWORK/../../build/sim-eeprom2-1to2-upgrade-library-cortexm3-iar-$--partNumber;L--$-em3xx$--stackProtection--$/sim-eeprom2-1to2-upgrade-library.a
    plugin/sim-eeprom2-1to2upgrade/sim-eeprom2-internal-1to2upgrade.c
  }
}

plugin(sim-eeprom2-1to2-upgrade-stub) {
  name=Simulated EEPROM version 1 to version 2 Upgrade Stub
  description=This library provides stub functionality for the sim-eeprom2-1to2-upgrade library.  The upgrade stub library is recommended since the stub adds minimal code space.  The full upgrade library should only be used when there are existing units in the field using SimEE1 that are meant to be upgraded.
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32~series[1],em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598,simulation

  providedApis=sim-eeprom2-1to2-upgrade

  plugin/sim-eeprom2-1to2upgrade-stub/sim-eeprom2-internal-1to2upgrade-stub.c (efr32,em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598)

  precompiled(efr32~series[1]) {
    file=$FRAMEWORK/../../build/sim-eeprom2-1to2-upgrade-stub-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$/sim-eeprom2-1to2-upgrade-stub-library.a
    plugin/sim-eeprom2-1to2upgrade-stub/sim-eeprom2-internal-1to2upgrade-stub.c
  }

  precompiled(em346,em355,em3555,em356,em357,em3581,em3582,em3585,em3586,em3587,em3588,em3591,em3592,em3595,em3596,em3597,em3598) {
    file=$FRAMEWORK/../../build/sim-eeprom2-1to2-upgrade-stub-library-cortexm3-iar-$--partNumber;L--$-em3xx/sim-eeprom2-1to2-upgrade-stub-library.a
    plugin/sim-eeprom2-1to2upgrade-stub/sim-eeprom2-internal-1to2upgrade-stub.c
  }
}

plugin(sim-eeprom2-to-nvm3-upgrade) {
  name=Simulated EEPROM version 2 to NVM3 Upgrade Library
  description=This library upgrades a device that used Simulated EEPROM version 2 to NVM3.  This upgrade code is a companion to the main NVM3 library and the upgrade cannot be run on its own.
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32~series[1],simulation

  api.sim-eeprom.header=plugin/sim-eeprom/sim-eeprom.h
  providedApis=sim-eeprom,sim-eeprom2-to-nvm3-upgrade

  precompiled(efr32~series[1]) {
    file=$FRAMEWORK/../../build/sim-eeprom2-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$$--stackProtection--$/sim-eeprom2-library.a
  }
  precompiled(efr32~series[1]) {
    file=$FRAMEWORK/../../build/sim-eeprom2-to-nvm3-upgrade-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$$--stackProtection--$/sim-eeprom2-to-nvm3-upgrade-library.a
  }

  precompiled(simulation) {
    file=$FRAMEWORK/../../build/sim-eeprom2-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$/sim-eeprom2-library.a
  }

  precompiled(simulation) {
    file=$FRAMEWORK/../../build/sim-eeprom2-to-nvm3-upgrade-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$/sim-eeprom2-to-nvm3-upgrade-library.a
  }

  $HAL/plugin/sim-eeprom2/sim-eeprom2.c (efr32)

  setup(macros) {
      -DSIMEE2_TO_NVM3_UPGRADE
    }

  options=reservePsstore

  reservePsstore.name=Reserve PS Store Space
  reservePsstore.description=Enable this option if upgrading from an application with PS Store enabled.
  reservePsstore.type=BOOLEAN
  reservePsstore.default=FALSE
}

plugin(sim-eeprom2-to-nvm3-upgrade-stub) {
  name=Simulated EEPROM version 2 to NVM3 Upgrade Stub
  description=This library provides stub functionality for the sim-eeprom2-to-nvm3-upgrade library.
  category=HAL
  quality=production
  root=$HAL

  architecture=efr32,simulation

  defaultState(efr32~series[2])=enabled

  providedApis=sim-eeprom2-to-nvm3-upgrade

  precompiled(efr32) {
    file=$FRAMEWORK/../../build/sim-eeprom2-to-nvm3-upgrade-stub-library-cortexm3-$--toolchainName--$-$--chipFamily;L--$$--dynamicPhy--$/sim-eeprom2-to-nvm3-upgrade-stub-library.a
  }

  precompiled(simulation) {
    file=$FRAMEWORK/../../build/sim-eeprom2-to-nvm3-upgrade-stub-library-unix-gcc-simulation-simulation/sim-eeprom2-to-nvm3-upgrade-stub-library.a
  }
}

plugin(psstore) {
  name=PS Store
  description=Persistent Store (PS Store) can be used to manage the data in the flash memory of the device. Data stored in PS keys within the flash memory is persistent across reset and power cycling of the device.
  category=HAL
  quality=development
  root=$HAL/plugin/psstore

  architecture=efr32

  providedApis=psstore
  api.psstore.header=store.h

  requiredApis=hal

  crc32.c
  psstore-cli.c
  psstore-flash.c
  store.c

  setup(commandLineConfiguration) {
    plugin ps-store dump, emAfPluginPsStoreDump
    plugin ps-store init, emAfPluginPsStoreInit
    plugin ps-store print-tags, emAfPluginPsStorePrintTags
    plugin ps-store write-tag, emAfPluginPsStoreWriteTag
    plugin ps-store delete-tag, emAfPluginPsStoreDeleteTag
  }

  setup(template) {
    # The GNU linker needs to be told how large the PSSTORE sections is. There is
    # a default value of zero in the HAL plugins, this plugin overrides it when
    # enabled by providing a more specific template setup line.
    (efr32~series[1]):psstoreSize=4096
    (efr32~series[2]):psstoreSize=16384
  }
}

plugin(stm32f103ret-library) {
  name=STM32F103RET Library
  description=Common functionality for STM32F103RET hosts.
  category=HAL
  quality=production
  root=$HAL

  architecture=stm32f103ret

  providedApis=crc,hal,spi-protocol,system-timer
  api.crc.header=host/crc.h
  api.hal.header=hal.h
  api.spi-protocol.header=host/spi-protocol-common.h
  api.system-timer.header=host/system-timer.h

  requiredApis=adc

  host/cortexm3/stm32f103ret/Libraries/CMSIS/CM3/CoreSupport/core_cm3.c
  host/cortexm3/stm32f103ret/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd.s
  host/cortexm3/stm32f103ret/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c
  host/cortexm3/stm32f103ret/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c
  host/cortexm3/stm32f103ret/micro.c
  host/cortexm3/stm32f103ret/spi-protocol.c
  host/cortexm3/stm32f103ret/system-timer.c
  host/cortexm3/stm32f103ret/uart.c
  host/generic/crc.c

  callbacks=config/spi-protocol-callback.info
}

plugin(unix-library) {
  name=Unix Library
  description=Common functionality for Unix hosts.
  category=HAL
  quality=production
  root=$HAL

  architecture=host-simulation,simulation,unix

  providedApis=crc,endian,hal,random,system-timer,token
  api.crc.header=micro/crc.h
  api.endian.header=micro/endian.h
  api.hal.header=hal.h
  api.random.header=micro/random.h
  api.system-timer.header=micro/system-timer.h
  api.token.header=micro/token.h
  api.token.condition=tokenSupport || conf.architectureMatches("host-simulation")

  options=tokenSupport

  tokenSupport.name=Token support (experimental)
  tokenSupport.description=Indicates whether the application will include experimental support for a file-based token system.
  tokenSupport.type=BOOLEAN
  tokenSupport.default=FALSE

  micro/generic/crc.c               (unix)
  micro/generic/endian.c            (unix)
  micro/generic/random.c            (unix)
  micro/generic/system-timer.c      (unix)
  micro/unix/host/micro.c           (unix)
  micro/unix/host/token-def-unix.c  (unix)
  micro/unix/host/token.c           (unix)
  micro/unix/host/token-ram-unix.c  (host-simulation,simulation)
  micro/unix/simulation/micro.c (host-simulation)
  micro/unix/simulation/random-sim.c (host-simulation)
  micro/unix/simulation/system-timer-sim.c (host-simulation)
  micro/unix/simulation/crc-sim.c (host-simulation)
  micro/unix/simulation/fake-eeprom.c (host-simulation)
}
